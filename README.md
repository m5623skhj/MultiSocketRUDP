# MultiSocketRUDP

1. 개요
2. 구성
3. 생각해 볼 문제

---

1. 개요

기존 RUDP 프로젝트[https://github.com/m5623skhj/RUDPServer]에서 부족한 점을 보완하기 위해 생성한 프로젝트 입니다.

기존 RUDP에서는 하나의 소켓이 여러 클라이언트에 대한 수신을, SendWorkerThread가 소유한 소켓에 대해서 클라이언트에 대한 송신을 담당하였는데,

위의 경우, 소켓에 너무 많은 부하가 발생 될 것으로 예상되어, 클라이언트와 소켓이 1:1 대응이 되도록 수정하였습니다.

---

2. 구성

* MultiSocketRUDPCore
  * UDP와 RIO를 사용하는 서버의 본체입니다.
  * 스레드는 아래와 같이 구성됩니다.
    * WorkerThread : IO 처리를 담당합니다.
    * RecvLogicThread : 클라이언트에게 받은 패킷을 바탕으로 연결, 연결 해제, 패킷 핸들러 호출 등을 담당합니다.
    * SessionBrokerThread : 클라이언트가 어떤 소켓에 연결을 할 것인지 알 수 있도록 지원해주는 스레드입니다.
    * RetransmissionThread : 패킷 유실 등으로 인한 타임 아웃이 발생했을 때, 해당 패킷을 재전송해주는 스레드입니다.
      * 일정 횟수 재전송을 해보고, 응답이 오지 않을 경우, 클라이언트가 끊겼다고 판단하고, 해당 세션을 정리합니다.
  
* RUDPSession
  * Core에서 관리되고 있는 각 세션의 정보를 담고 있는 객체입니다.
  * 하나의 UDP 소켓을 가지고 있으며, 논리적으로는 1개의 클라이언트를 연결합니다.
  * 서버가 초기화 될 때, 유저가 지정한 개수로 생성되며, 생성될 때, 가지고 있는 소켓을 미리 열어 놓습니다.
  
* RUDPSessionBroker
  * 최초로 클라이언트와 연결하여, 유저에게 실제로 연결될 소켓을 알려주는 역할을 담당합니다.
  * BuildConfig.h의 USE_IOCP_SESSION_BROKER 값으로 IOCP를 사용하는 세션 브로커를 사용할지, 단일 스레드 세션 브로커를 사용할지 조정 가능합니다.
    * 기본적으로는 단일 스레드 세션 브로커를 사용합니다.
  * 유저가 접속하면, 세션 브로커는 연결할 세션 정보와 세션 키를 발급하고 연결을 종료시킵니다.
    * 위에서 얻은 정보로 클라이언트가 패킷을 송신하면, 서버에서는 예약된 세션키를 비교하고 RUDPSession을 해당 클라이언트에게 귀속 시킵니다.

---

3. 생각해 볼 문제

* 클라이언트가 세션 브로커로 부터 세션 정보를 받은 후, 세션에 연결 요청을 하지 않는다면 어떻게 처리할지?
  * 해당 세션은, usingSessionMap에 편입될 것이니, 클라이언트로 부터 아무 반응이 없다면, 일정 시간 이후 타임 아웃 되어서 다시 unusingSessionList에 편입?
  * 위의 방식으로는 예외 사항들이 발생할 것 같은데, 다른 방법은 없을지?

---
